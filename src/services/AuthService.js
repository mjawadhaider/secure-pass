class AuthService {
    // Check if biometric authentication is available
    static async isBiometricAvailable() {
        // Simplified check that works more reliably
        if (typeof window !== "undefined") {
            // For WebAuthn on supported browsers
            if (window.PublicKeyCredential) {
                try {
                    return await PublicKeyCredential.isUserVerifyingPlatformAuthenticatorAvailable();
                } catch (error) {
                    console.error("Error checking biometric availability:", error);
                }
            }
        }

        // Default to false if checks fail
        return false;
    }

    // Authenticate with biometrics
    static async authenticateWithBiometric() {
        try {
            if (!window.PublicKeyCredential) {
                return {msg: 'window.PublicKeyCredential is false', success: false};
            }

            // Create a simple credential request
            const challenge = new Uint8Array(32);
            window.crypto.getRandomValues(challenge);

            const publicKeyCredentialRequestOptions = {
                challenge: new Uint8Array(32),
                allowCredentials: [], // previously registered credentials
                timeout: 60000,
                userVerification: 'required' // Force user verification (biometric or PIN)
            };

            // This will trigger the device's authentication prompt
            const credential = await navigator.credentials.get({
                publicKey: publicKeyCredentialRequestOptions
            });

            console.log("Authenticated!", credential);

            if (!credential) {
                const isAuthCreated = AuthService.createAuthentication();
                if (isAuthCreated) {
                    return {
                        msg: typeof isAuthCreated === 'string' ? isAuthCreated : JSON.stringify(isAuthCreated),
                        success: false
                    };
                }
                return {msg: 'AuthService.createAuthentication() has returned undefined. window.PublicKeyCredential is null or undefined', success: false};
            }

            return {msg: credential, success: true};
        } catch (error) {
            console.error("Authentication error:", error);
            return {msg: error.message || error, success: false};
        }
    }

    static async createAuthentication() {
        if (!window.PublicKeyCredential) {
            return;
        }

        const publicKey = {
            challenge: new Uint8Array([21, 31, 105 /* 29 more random bytes generated by the server */]),
            rp: {
                name: "ACME Corporation"
            },
            user: {
                id: Uint8Array.from(window.atob("MIIBkzCCATigAwIBAjCCAZMwggE4oAMCAQIwggGTMII="), c => c.charCodeAt(0)),
                name: "alex.mueller@example.com",
                displayName: "Alex MÃ¼ller",
            },
            pubKeyCredParams: [
                {
                    type: "public-key",
                    alg: -7 // "ES256" as registered in the IANA COSE Algorithms registry
                },
                {
                    type: "public-key",
                    alg: -257 // Value registered by this specification for "RS256"
                }
            ],
            authenticatorSelection: {
                userVerification: "preferred"
            },
            timeout: 360000,  // 6 minutes
            excludeCredentials: [
                {
                    "id": Uint8Array.from(window.atob("ufJWp8YGlibm1Kd9XQBWN1WAw2jy5In2Xhon9HAqcXE="), c => c.charCodeAt(0)),
                    "type": "public-key"
                },
                {
                    "id": Uint8Array.from(window.atob("E/e1dhZc++mIsz4f9hb6NifAzJpF1V4mEtRlIPBiWdY="), c => c.charCodeAt(0)),
                    "type": "public-key"
                }
            ],
            extensions: {"appidExclude": "https://acme.example.com"}
        };

        navigator.credentials.create({publicKey})
            .then(function (newCredentialInfo) {
                return newCredentialInfo;
            }).catch(function (err) {
            return err;
        });
    }

    // Save PIN to localStorage (encrypted in production)
    static savePin(pin) {
        localStorage.setItem('securepass_pin', pin);
        return true;
    }

    // Check if PIN exists
    static hasPin() {
        return !!localStorage.getItem('securepass_pin');
    }

    // Verify PIN
    static verifyPin(pin) {
        const savedPin = localStorage.getItem('securepass_pin');
        return savedPin === pin;
    }
}

export default AuthService;
